version: 3

env:
  SOLO_COMMAND:
    sh: |
      if [ "${USE_RELEASED_VERSION}" = "true" ]; then
        echo "npx @hashgraph/solo"
      else
        echo "npm run solo-test --"
      fi

vars:
  DEPLOYMENT: "port-forward-test-deployment"
  CLUSTER_NAME: "port-forward-test-cluster"
  CONTEXT: "kind-port-forward-test-cluster"

tasks:
  deploy:
    desc: Deploy a test network using one-shot single deploy
    dir: ../..
    cmds:
      # Install Solo CLI if using released version
      - cmd: |
          if [ "${USE_RELEASED_VERSION}" = "true" ]; then
            npm i @hashgraph/solo@latest
          else
            echo "Skipping npm install - using development version"
          fi

      # Clean up any existing Kind clusters
      - cmd: |
          for cluster in $(kind get clusters 2>/dev/null); do
            kind delete cluster -n $cluster
          done
        ignore_error: true

      # Clean up Solo data
      - cmd: rm -rf ~/.solo
        ignore_error: true

      # Create Kind cluster
      - cmd: kind create cluster -n {{ .CLUSTER_NAME }}

      # Solo one-shot single deploy
      - cmd: |
          $SOLO_COMMAND one-shot single deploy

  test-refresh:
    desc: Test the refresh command by killing a port-forward and then restoring it
    dir: ../..
    cmds:
      # Show current port-forwards
      - cmd: |
          echo "==== Current port-forward processes ===="
          ps -ef | grep '[k]ubectl port-forward' || echo "No port-forwards found"
          echo ""

      # Get one of the port-forward PIDs and kill it
      - cmd: |
          echo "==== Killing a random port-forward process ===="
          # Use bracket notation to avoid matching the grep process itself
          PID=$(ps -ef | grep '[k]ubectl port-forward' | head -1 | awk '{print $2}')
          if [ -n "$PID" ]; then
            echo "Killing port-forward process PID: $PID"
            
            # Extract port number - it should be in format localPort:podPort
            # Using awk to reliably extract the last field and then cut to get the local port
            FULL_PORT_SPEC=$(ps -ef | grep '[k]ubectl port-forward' | head -1 | awk '{print $NF}')
            PORT=$(echo "$FULL_PORT_SPEC" | cut -d':' -f1)
            
            # Validate PORT is a number within valid range
            if ! echo "$PORT" | grep -qE '^[0-9]+$'; then
              echo "Error: Could not extract valid port number from: $FULL_PORT_SPEC"
              exit 1
            fi
            
            if [ "$PORT" -lt 1 ] || [ "$PORT" -gt 65535 ]; then
              echo "Error: Port number $PORT is out of valid range (1-65535)"
              exit 1
            fi
            
            echo "Port being killed: $PORT"
            
            kill -9 $PID
            sleep 2
            
            # Verify the process was actually killed
            if ps -p $PID > /dev/null 2>&1; then
              echo "Error: Process $PID still running"
              exit 1
            fi
            
            echo "Process killed successfully"
            # Store the killed port for later verification
            echo "$PORT" > /tmp/killed_port.txt
          else
            echo "No port-forward processes found to kill"
            exit 1
          fi

      # Show port-forwards after killing one
      - cmd: |
          echo ""
          echo "==== Port-forward processes after killing one ===="
          ps -ef | grep '[k]ubectl port-forward' || echo "No port-forwards found"
          echo ""

      # Run refresh command
      - cmd: |
          echo "==== Running deployment refresh command ===="
          $SOLO_COMMAND deployment refresh port-forwards --deployment {{ .DEPLOYMENT }}

      # Show port-forwards after refresh
      - cmd: |
          echo ""
          echo "==== Port-forward processes after refresh ===="
          ps -ef | grep '[k]ubectl port-forward' || echo "No port-forwards found"
          echo ""

  verify:
    desc: Verify all expected port-forwards are running by checking remote config
    dir: ../..
    cmds:
      - cmd: |
          echo "==== Verifying port-forwards ===="
          echo "Checking that all port-forwards from remote config are running..."
          
          # Get the list of port-forwards from the process list using bracket notation
          RUNNING_PORTS=$(ps -ef | grep '[k]ubectl port-forward' | awk '{print $NF}' | cut -d':' -f1 | sort -u)
          
          echo "Running port-forwards on ports: $RUNNING_PORTS"
          
          # Count them
          PORT_COUNT=$(echo "$RUNNING_PORTS" | wc -w)
          echo "Total running port-forwards: $PORT_COUNT"
          
          # We expect at least 2 port-forwards (consensus node and block node)
          if [ "$PORT_COUNT" -ge 2 ]; then
            echo "✓ Verification PASSED: Found expected number of port-forwards"
            
            # Check if the killed port was restored
            if [ -f /tmp/killed_port.txt ]; then
              KILLED_PORT=$(cat /tmp/killed_port.txt)
              # Check if the killed port is in the space-separated list of running ports
              if echo " $RUNNING_PORTS " | grep -q " ${KILLED_PORT} "; then
                echo "✓ Verification PASSED: Killed port $KILLED_PORT was successfully restored"
              else
                echo "✗ Verification FAILED: Killed port $KILLED_PORT was NOT restored"
                echo "Running ports: $RUNNING_PORTS"
                exit 1
              fi
              rm -f /tmp/killed_port.txt
            fi
          else
            echo "✗ Verification FAILED: Expected at least 2 port-forwards, found $PORT_COUNT"
            exit 1
          fi

  test:
    desc: Run complete test workflow - deploy, kill port-forward, refresh, verify
    dir: ../..
    cmds:
      - task: deploy
      - task: test-refresh
      - task: verify
      - task: solo-smoke-test

  solo-smoke-test:
    desc: Run Solo smoke test script from .github/workflows/script/solo_smoke_test.sh
    dir: ../..
    cmds:
      # Deploy the network with required components for smoke test
      - task: deploy

      # Run solo smoke test
      - cmd: |
          export SOLO_DEPLOYMENT="{{ .DEPLOYMENT }}"
          # Get the namespace from the deployment configuration
          NAMESPACE=$(npm run solo-test -- deployment config list --deployment {{ .DEPLOYMENT }} 2>&1 | grep -oP 'solo-\w+' | head -1)
          if [ -z "$NAMESPACE" ]; then
            # Fallback: try to get it from kubectl
            NAMESPACE=$(kubectl get deployments -A -l app=network-node --no-headers | awk '{print $1}' | head -1)
          fi
          export SOLO_NAMESPACE="${NAMESPACE:-solo-ns}"
          echo "Using namespace: $SOLO_NAMESPACE"
          ./.github/workflows/script/solo_smoke_test.sh

  destroy:
    desc: Destroy the test deployment
    dir: ../..
    cmds:
      # Solo one-shot single destroy
      - cmd: $SOLO_COMMAND one-shot single destroy --deployment {{ .DEPLOYMENT }}
        ignore_error: true

      # Delete Kind cluster
      - cmd: kind delete cluster -n {{ .CLUSTER_NAME }}
        ignore_error: true

  default:
    desc: Run the complete test
    cmds:
      - task: test
